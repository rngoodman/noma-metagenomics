---
title: "Noma Metagenomics: Short-read taxonomic based metagenomic analysis of noma vs healthy human saliva samples in R"
author: "Richard Goodman"
date: "`r Sys.Date()`"
output: html_document
---

This analysis was used in the short-read (Illumina) taxonomic based metagenomic analysis of noma vs healthy human saliva samples in R posted as a preprint on bioRxiv:

Shotgun metagenomic analysis of the oral microbiomes of noma patients reveals a novel disease-associated organism and potential avenues for disease prevention

Olaleye, M., O'Ferrall A.M., Goodman, R.N. et al. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Getting Started in R 

## 1.1  Installing and Loading Packages

Install all necessary packages into R.

```{r, warning=FALSE, message=FALSE}

# Make sure these are all installed as packages first 
# Load necessary libraries
library(readxl)
library(pheatmap)
library(dplyr)
library(tidyr)
library(tibble)
library(RColorBrewer)
library(miaViz)
library(scater)
library(mia)
library(TreeSummarizedExperiment)
library(here)
library(readr)
library(phyloseq)
library(DESeq2)
library(ggsignif)
library(ggrepel)
library(gridExtra)
library(vegan)
library(randomForest)
library(e1071)
library(pROC)
library(ROCR)
library(caret) 
```

# 2. Import and Clean Data

We will be importing MetaPhlan style Bracken data 

First we'll write a function to import MetaPhlan style bracken data 

## 2.1 Load taxonomic data

```{r}
file_path =  "../data/noma_HMP_saliva_bracken_MetaPhlan_style_report_bacteria_noma_v_healthy_saliva_A1_A19_corrGB.txt"
sample_data_path = "../data/Samples_healthy_v_noma_saliva_A1_A19_corrGB.csv"

# Import data
tse_metaphlan_noma = loadFromMetaphlan(file_path)

# Defining the TSE for the rest of the script
tse_metaphlan = tse_metaphlan_noma

```

## 2.2 Add metadata

```{r, message=FALSE}

patient_metadata = read_excel("../data/micro_study_metadata.xlsx")
sample_to_patient = read_excel("../data/sample_to_patient_A1_A40.xlsx")

metadata = dplyr::inner_join(patient_metadata, sample_to_patient, by = "respondent_id")

metadata_2 = metadata %>% filter(sample_name  %in% colnames(tse_metaphlan_noma))

coldata = data.frame(sample_name = colnames(tse_metaphlan_noma))

metadata_3 = dplyr::left_join(coldata, metadata_2, by = "sample_name")

# Create a DataFrame with this information
metadata_df = DataFrame(metadata_3)
rownames(metadata_df) = metadata_3$sample_name
t_metadata_df = t(metadata_df)
ncol(t_metadata_df)


# Add this DataFrame as colData to your TreeSummarizedExperiment object
colData(tse_metaphlan_noma) = metadata_df


tse_metaphlan = tse_metaphlan_noma
  
```

## 2.3  Adding diseased or healthy condition metadata 


```{r}

# Assume your TreeSummarizedExperiment object is called `tse`
# Get the current sample names (column names)
sample_names <- colnames(tse_metaphlan)
sample_names

# Create a vector indicating the condition (diseased or healthy)
# sample_1 to sample_17 are diseased, and sample_18 to sample_37 are healthy
condition <- c(rep("diseased", 17), rep("healthy", 20))

# Create a DataFrame with this information
sample_metadata_disease <- DataFrame(condition = condition)
rownames(sample_metadata_disease) = sample_names
sample_metadata_disease

# Add this DataFrame as colData to your TreeSummarizedExperiment object
colData(tse_metaphlan) <- sample_metadata_disease

# Check that colData was added successfully
head(as.data.frame(colData(tse_metaphlan)), n = 37)
```
 
## 2.4 Inspecting the Data

You can inspect the data with these functions.

The output is not printed here as it would be too large. 

```{r, eval=FALSE}

(count <- assays(tse_metaphlan)[[1]])

head(rowData(tse_metaphlan))

head(colData(tse_metaphlan))

head(metadata(tse_metaphlan))

```
## 2.5 Converting TSE to other common data formats e.g. Phyloseq 

```{r}
phyloseq_metaphlan = makePhyloseqFromTreeSE(tse_metaphlan)
phyloseq_obj = makePhyloseqFromTreeSE(tse_metaphlan)
```



# 3. Non-parametric statistical tests 

Non-parametric methods were used to determine the difference between samples based on the categorical variable of disease status. Non-parametric tests are used for metagenomic data due to the non-normal distribution of the data. We used the Bray-Curtis dissimilarity matrix for all these tests. 

## 3.1 Preparing the data

```{r}
# See above "Converting TSE to other common data formats e.g. Phyloseq"
# Use makePhyloseqFromTreeSE from Miaverse

tse_metaphlan_noma = tse_metaphlan


# make an assay for abundance
tse_metaphlan_noma <- transformAssay(tse_metaphlan_noma, assay.type="counts", method="relabundance")

taxonomyRanks(tse_metaphlan_noma)
colData(tse_metaphlan_noma)

# make an altExp and matrix for order
tse_metaphlan_noma_genus = altExp(tse_metaphlan_noma, "Genus")

# Add metadata to colData 
colData(tse_metaphlan_noma_genus)
colData(tse_metaphlan_noma_genus) <- sample_metadata_disease

metadata_df = colData(tse_metaphlan_noma_genus)

metadata_noma_genus = as.data.frame(colData(tse_metaphlan_noma_genus))
metadata_noma_genus

# genus
phyloseq_noma = makePhyloseqFromTreeSE(tse_metaphlan_noma_genus)

phyloseq_noma_esd = transform_sample_counts(phyloseq_noma, function(x) 1E6 * x/sum(x))

ntaxa(phyloseq_noma_esd) 
nsamples(phyloseq_noma_esd) 
```


## 3.1 Permanova across entire dataset

```{r}


set.seed(123456)

# Calculate bray curtis distance matrix on main variables 
noma.bray = phyloseq::distance(phyloseq_noma_esd, method = "bray")
sample.noma.df <- data.frame(sample_data(phyloseq_noma_esd))
permanova_all = vegan::adonis2(noma.bray ~ condition , data = sample.noma.df)
permanova_all



```

Next we will test the beta dispersion 

```{r}
# All together now
vegan::adonis2(noma.bray ~ condition, data = sample.noma.df)
beta <- betadisper(noma.bray, sample.noma.df$condition)
permutest(beta)
# we don't want this to be significant 
```


## 3.2 Anosim across entire dataset

```{r}
condition_group = get_variable(phyloseq_noma_esd, "condition")
set.seed (123456)
anosim(distance(phyloseq_noma_esd, "bray"), condition_group)
condition_ano = anosim(distance(phyloseq_noma_esd, "bray"), condition_group)
condition_ano
```


## 3.3 MRPP across entire dataset

```{r}
#condition
noma.bray <- phyloseq::distance(phyloseq_noma_esd, method = "bray") # Calculate bray curtis distance matrix
condition_group = get_variable(phyloseq_noma_esd, "condition") # Make condition Grouping
# Run MRPP
set.seed(123456)
vegan::mrpp(noma.bray, condition_group, permutations = 999, 
            weight.type = 1, strata = NULL, parallel = getOption("mc.cores"))

```

## 3.4 Outputting non paramteric tests into table

```{r}
# Define the list of metadata variables you want to test
variables_to_test <- c("condition")

# Set a seed for reproducibility of permutation-based tests
set.seed(123456)

bray_dist <- phyloseq::distance(phyloseq_noma_esd, method = "bray")

# Extract the sample data into a data frame for use with adonis2
sample_df <- data.frame(sample_data(phyloseq_noma_esd))

# Create an empty list to store the results from each iteration
results_list <- list()

# Loop through each variable name in the 'variables_to_test' vector
for (variable in variables_to_test) {
  
  message(paste("Running tests for variable:", variable))
  
  # PERMANOVA (adonis2) 
  # Create the statistical formula dynamically for the current variable
  formula <- as.formula(paste("bray_dist ~", variable))
  
  # Run the PERMANOVA test using the adonis2 function
  permanova_res <- vegan::adonis2(formula, data = sample_df, permutations = 999)
  
  # Extract the p-value from the results. It's in the 'Pr(>F)' column.
  p_permanova <- permanova_res$`Pr(>F)`[1]
  
  # ANOSIM 
  # Get the grouping factor (the actual variable data) from the phyloseq object
  grouping_factor <- phyloseq::get_variable(phyloseq_noma_esd, variable)
  
  # Run the ANOSIM test
  anosim_res <- vegan::anosim(bray_dist, grouping_factor, permutations = 999)
  
  # Extract the p-value (significance) from the ANOSIM result
  p_anosim <- anosim_res$signif
  
  # MRPP 
  # The grouping factor is the same as for ANOSIM
  # Run the MRPP test
  mrpp_res <- vegan::mrpp(bray_dist, grouping_factor, permutations = 999)
  
  # Extract the p-value from the MRPP result
  p_mrpp <- mrpp_res$Pvalue
  
  # Store Results 
  # Store the p-values for the current variable in our results list.
  # We create a small data frame for this iteration's results.
  results_list[[variable]] <- data.frame(
    Variable = paste0(variable, "."),
    `permanova.` = p_permanova,
    `anosim.` = p_anosim,
    `mrpp.` = p_mrpp,
    # 'check.names = FALSE' prevents R from changing our column names
    check.names = FALSE 
  )
}

# Combine the list of individual data frames into one final table
final_results_table <- do.call(rbind, results_list)

# Clean up the row names of the final table
rownames(final_results_table) <- NULL

# Print the final, consolidated table to the console
print(final_results_table)

write.csv(final_results_table, file ="../tbls/Table_1A.csv")
```


## 3.5 Permanova function for specific taxa

```{r}

# create a 
tse_metaphlan_genus = altExp(tse_metaphlan, "Genus") 

# Extract the counts and taxonomic table
counts <- assay(tse_metaphlan_genus, "counts")
tax_table <- rowData(tse_metaphlan_genus)$Genus  # Replace "Genus" with your taxonomic level of interest
sample_data <- colData(tse_metaphlan_genus)

groups = as.data.frame(sample_data)

# Aggregate counts by Genus
aggregated_counts <- rowsum(counts, tax_table)

# Create a new aggregated TreeSummarizedExperiment object
tse_aggregated <- TreeSummarizedExperiment(assays = list(counts = aggregated_counts), 
                                           colData = sample_data)

# Calculate relative abundances
relative_abundances <- sweep(assay(tse_aggregated, "counts"), 2, colSums(assay(tse_aggregated, "counts")), FUN = "/") * 100

# Convert to a data frame and group by Treatment
relative_df <- as.data.frame(t(relative_abundances))

set.seed (123456)

# Define the vector of genera names (without the "g__" prefix)
genera <- c("Prevotella", "Treponema", "Neisseria", "Bacteroides", 
            "Filifactor", "Porphyromonas", "Fusobacterium", "Escherichia",
            "Selenomonas", "Aggregatibacter", "Capnocytophaga")

# Initialize an empty data frame to store the results
permanova_taxa_results <- data.frame(Genus = character(), pvalue = numeric(), stringsAsFactors = FALSE)

# Loop over each genus
for (genus in genera) {
  set.seed (123456)
  # Subset the data for the genus; adjust column selection as needed
  subset_data <- relative_df %>% select(paste0("g__", genus))
  
  # Calculate the Bray-Curtis distance
  bray_dist <- vegdist(subset_data, method = "bray")
  
  # Run PERMANOVA using adonis2
  adonis_result <- adonis2(bray_dist ~ condition, data = groups)
  
  # Extract the p-value for the sample_type factor (usually in the first row)
  pval <- adonis_result$`Pr(>F)`[1]
  
  # Append the result to the results data frame
  permanova_taxa_results <- rbind(permanova_taxa_results, data.frame(Genus = genus, pvalue = pval))
}

print(permanova_taxa_results)

```


# 4. Relative Abundance 

The top 20 most abundant genera were selected from across the entire dataset and visualised with the plotAbundance function of miaViz.

## 4.1 Plotting relative abundance of genera across samples 

```{r, warning=FALSE}
  
 # Check taxonomy ranks 
  taxonomyRanks(tse_metaphlan)
  
  # make an assay for abundance
  tse_metaphlan <- transformAssay(tse_metaphlan, assay.type="counts", method="relabundance")
  
  # make an altExp and matrix for Genus
  altExp(tse_metaphlan,"Genus") <- agglomerateByRank(tse_metaphlan,"Genus")
  
  # make a dataframe of relative abundance 
  relabundance_df_Genus <- as.data.frame(assay(altExp(tse_metaphlan, "Genus"), "relabundance"))
  
  # make a matric of relative abundance 
  relabundance_matrix_Genus <- assay(altExp(tse_metaphlan, "Genus"), "relabundance")
  
  # calculate the total relative abundance of each Genus (row sums)
  total_relabundance_Genus <- rowSums(relabundance_matrix_Genus)
  
  # Identify the top 20 top Genuss
  top_Genus <- names(sort(total_relabundance_Genus, decreasing = TRUE)[1:20])
  # Delete everything from start to Genus
  top_Genus = sub(".*_g__","",top_Genus)
  # Add Genus back in 
  top_Genus = paste0(paste(rep("g__", length(top_Genus)), top_Genus))
  # Delete the space introduced by this 
  top_Genus = sub(" ","",top_Genus)
  top_Genus
  
  # make a new tse_metaphlan where the top 14 Genuss are recognised, while others are "other"
  tse_metaphlan_top_20_Genus <- tse_metaphlan
  
  rowData(tse_metaphlan_top_20_Genus)$Genus <- ifelse(rowData(tse_metaphlan_top_20_Genus)$Genus %in% top_Genus, rowData(tse_metaphlan_top_20_Genus)$Genus, "-other")
  
  genus_colors <- c(
    "-other" = "#E41A1C",
    "g__Actinomyces" = "#377EB8",
    "g__Aggregatibacter" = "#4DAF4A",
    "g__Bacteroides" = "#984EA3",
    "g__Campylobacter" = "#FF7F00",
    "g__Capnocytophaga" = "#FFFF33",
    "g__Dialister" = "#E7298A",
    "g__Escherichia" = "#A65628",
    "g__Filifactor" = "#F781BF",
    "g__Fusobacterium" = "#999999",
    "g_Gemella" = "#1B9E77",
    "g__Haemophilus" = "#D95F02",
    "g__Leptotrichia" = "#7570B3",
    "g__Neisseria" = "#E7298A",
    "g__Porphyromonas" = "#66A61E",
    "g__Prevotella" = "#E6AB02",
    "g__Rothia" = "#66C2A5",
    "g__Schaalia" = "#FC8D62",
    "g__Selenomonas" = "#8DA0CB",
    "g__Streptococcus" = "#E78AC3",
    "g__Tannerella" = "#E41A1C",
    "g__Treponema" = "#A6D854",
    "g__Veillonella" = "#FFD92F"
  )
  
  Genus_plot <- plotAbundance(tse_metaphlan_top_20_Genus, 
                              assay.type = "relabundance", 
                              rank = "Genus", 
                              add_x_text = TRUE) +
    theme(plot.margin = ggplot2::margin(t = 30, r = 10, b = 10, l = 10))  
  

  Genus_plot_cols = Genus_plot + scale_fill_manual(values=genus_colors)
  Genus_plot_cols

  ggsave("../imgs/Figure_1B.png", plot =  Genus_plot_cols, width = 28, height = 16, dpi = 400)
  
```


## 4.2 Creating a table of average relative abundance 

```{r}
  
  # Get numbers in table 
  
  # Total 
  top_Genus_numbers_basic = sort(total_relabundance_Genus, decreasing = TRUE)
  top_Genus_numbers_df = as.data.frame(top_Genus_numbers_basic)
  top_Genus_numbers = as.tibble(top_Genus_numbers_df)
  
  rownames(top_Genus_numbers_df) <- gsub(".*(g__*)", "\\1", rownames(top_Genus_numbers_df))
  
top_Genus_pc = top_Genus_numbers %>% 
    mutate(top_Genus_percentage = (top_Genus_numbers_basic/sum(top_Genus_numbers$top_Genus_numbers_basic)) * 100) %>% 
    mutate(top_Genus = rownames(top_Genus_numbers_df))

sum(top_Genus_pc$top_Genus_percentage)

top_Genus_pc$top_20_Genus = ifelse(top_Genus_pc$top_Genus %in% top_Genus, top_Genus_pc$top_Genus, "-other")
top_Genus_pc$top_Genus_above_1 = ifelse(top_Genus_pc$top_Genus_percentage > 1, top_Genus_pc$top_Genus, "-other")
top_Genus_above_1 = unique(top_Genus_pc$top_Genus_above_1)
top_Genus_pc$top_Genus_above_0.1 = ifelse(top_Genus_pc$top_Genus_percentage > 0.1, top_Genus_pc$top_Genus, "-other")
top_Genus_above_0.1 = unique(top_Genus_pc$top_Genus_above_0.1)

mat_colors <- c(brewer.pal(8, "Dark2"), brewer.pal(8, "Set1"), brewer.pal(8, "Set2"))

# Create the abundance plot with a single stacked bar for 1%
p = ggplot(top_Genus_pc, aes(x = 1, y = top_Genus_percentage, fill = top_Genus_above_1)) +
  geom_bar(stat = "identity") +
  labs(x = "", y = "Abundance (%)", title = "Abundance Plot of Genus") +
  theme_minimal() +
  scale_fill_manual(values = genus_colors, name = "Top genera above 0.1%") +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

p

ggsave("../imgs/Supplementary_Figure_4.png", plot =  p, width = 28, height = 16, dpi = 400)
```
## 4.3 Statistical differences in relative abundance of top 20 genera

```{r, warning=FALSE}

  
  plot_relab_boxplot = function(genus = relative_df$g__Prevotella,
                                sample_data = sample_data,
                                title = "Prevotella",
                                ...) {  
    rel_df = data.frame (
      genus = genus,
      condition = sample_data
    )
    
    # Create the boxplot with significance
    p = ggplot(rel_df, aes(x = condition, y = genus, fill = condition)) +
      geom_boxplot() +
      geom_signif(comparisons = list(c("healthy", "diseased")),
                  map_signif_level = FALSE,
                  test = wilcox.test) +
      labs(title = title,
           x = "condition",
           y = "Relative Abundance") +
      theme_minimal() +
      scale_fill_manual(values = c("healthy" = "#4682B4", "diseased" = "#E41A1C")) +
      theme(legend.position = "none")
    
    print(p)
  }
  
  
  Actinomyces_rel_bp = plot_relab_boxplot(genus = relative_df$g__Actinomyces,
                                          sample_data = sample_data,
                                          title = "Actinomyces")
  
  Aggregatibacter_rel_bp = plot_relab_boxplot(genus = relative_df$g__Aggregatibacter,
                                         sample_data = sample_data,
                                         title = "Aggregatibacter")
  
  Bacteroides_rel_bp = plot_relab_boxplot(genus = relative_df$g__Bacteroides,
                                         sample_data = sample_data,
                                         title = "Bacteroides")
  
  Campylobacter_rel_bp = plot_relab_boxplot(genus = relative_df$g__Campylobacter,
                                         sample_data = sample_data,
                                         title = "Campylobacter")

  Capnocytophaga_rel_bp = plot_relab_boxplot(genus = relative_df$g__Capnocytophaga,
                                         sample_data = sample_data,
                                         title = "Capnocytophaga")

  Dialister_rel_bp = plot_relab_boxplot(genus = relative_df$g__Dialister,
                                         sample_data = sample_data,
                                         title = "Dialister")
  
  Escherichia_rel_bp = plot_relab_boxplot(genus = relative_df$g__Escherichia,
                                         sample_data = sample_data,
                                         title = "Escherichia")
  
  Filifactor_rel_bp = plot_relab_boxplot(genus = relative_df$g__Filifactor,
                                         sample_data = sample_data,
                                         title = "Filifactor")
  
  Fusobacterium_rel_bp = plot_relab_boxplot(genus = relative_df$g__Fusobacterium,
                                         sample_data = sample_data,
                                         title = " Fusobacterium")

  Gemella_rel_bp = plot_relab_boxplot(genus = relative_df$g__Gemella,
                                         sample_data = sample_data,
                                         title = "Gemella")

  Haemophilus_rel_bp = plot_relab_boxplot(genus = relative_df$g__Haemophilus,
                                         sample_data = sample_data,
                                         title = "Haemophilus")

  Leptotrichia_rel_bp = plot_relab_boxplot(genus = relative_df$g__Leptotrichia,
                                         sample_data = sample_data,
                                         title = "Leptotrichia")

  Neisseria_rel_bp = plot_relab_boxplot(genus = relative_df$g__Neisseria,
                                         sample_data = sample_data,
                                         title = "Neisseria")

  Porphyromonas_rel_bp = plot_relab_boxplot(genus = relative_df$g__Porphyromonas,
                                         sample_data = sample_data,
                                         title = "Porphyromonas")
  
  Prevotella_rel_bp = plot_relab_boxplot(genus = relative_df$g__Prevotella,
                                         sample_data = sample_data,
                                         title = "Prevotella")
  
  Rothia_rel_bp = plot_relab_boxplot(genus = relative_df$g__Rothia,
                                         sample_data = sample_data,
                                         title = "Rothia")
  
  Schaalia_rel_bp = plot_relab_boxplot(genus = relative_df$g__Schaalia,
                                         sample_data = sample_data,
                                         title = "Schaalia")
  
  Selenomonas_rel_bp = plot_relab_boxplot(genus = relative_df$g__Selenomonas,
                                         sample_data = sample_data,
                                         title = "Selenomonas")
  
  Streptococcus_rel_bp = plot_relab_boxplot(genus = relative_df$g__Streptococcus,
                                         sample_data = sample_data,
                                         title = "Streptococcus")

  Tannerella_rel_bp = plot_relab_boxplot(genus = relative_df$g__Tannerella,
                                         sample_data = sample_data,
                                         title = "Tannerella")

  
  Treponema_rel_bp = plot_relab_boxplot(genus = relative_df$g__Treponema,
                                         sample_data = sample_data,
                                         title = "Treponema")
  
  Veillonella_rel_bp = plot_relab_boxplot(genus = relative_df$g__Veillonella,
                                         sample_data = sample_data,
                                         title = "Veillonella")
  
  grid.arrange(Actinomyces_rel_bp, Gemella_rel_bp, Rothia_rel_bp, Schaalia_rel_bp, Streptococcus_rel_bp, Veillonella_rel_bp,
               Aggregatibacter_rel_bp,Bacteroides_rel_bp, Capnocytophaga_rel_bp, Dialister_rel_bp, Escherichia_rel_bp, Filifactor_rel_bp, 
               Neisseria_rel_bp, Porphyromonas_rel_bp, Prevotella_rel_bp, Selenomonas_rel_bp, Tannerella_rel_bp, Treponema_rel_bp,
               ncol=6, top = "Relative Abundance")



ggsave("../imgs/Supplementary_Figure_3.png", 
arrangeGrob(Actinomyces_rel_bp, Gemella_rel_bp, Rothia_rel_bp, Schaalia_rel_bp, Streptococcus_rel_bp,
Veillonella_rel_bp,
               Aggregatibacter_rel_bp,Bacteroides_rel_bp, Capnocytophaga_rel_bp, Dialister_rel_bp, Escherichia_rel_bp, Filifactor_rel_bp, 
               Neisseria_rel_bp, Porphyromonas_rel_bp, Prevotella_rel_bp, Selenomonas_rel_bp, Tannerella_rel_bp, Treponema_rel_bp,
               ncol=6),
width = 20,
height = 10)
  
```


# 5. Differential Analysis with Deseq

Differential analysis used the DESeq2 model on normalised count data and determined fold-change and significant differences between noma and healthy samples at the genera level. 

## 5.1 Preparing the data

Use makePhyloseqFromTreeSE from Miaverse to convert 

```{r, message=FALSE}
# Assume your TreeSummarizedExperiment object is called `tse`
# Get the current sample names (column names)
tse_metaphlan_genus = altExp(tse_metaphlan, "Genus") 
sample_names_genus <- colnames(tse_metaphlan_genus)
sample_names_genus

# Create a vector indicating the condition (diseased or healthy)
# Assuming sample_1 to sample_19 are diseased, and sample_20 to sample_22 are healthy
condition <- c(rep("diseased", 17), rep("healthy", 20))

# Create a DataFrame with this information
sample_metadata_disease <- DataFrame(condition = condition)
rownames(sample_metadata_disease) = sample_names
sample_metadata_disease
head(as.data.frame(sample_metadata_disease), n = 37)

# Add this DataFrame as colData to your TreeSummarizedExperiment object
colData(tse_metaphlan_genus) <- sample_metadata_disease

# Check that colData was added successfully
colData(tse_metaphlan_genus)

# Use makePhyloseqFromTreeSE from Miaverse

phyloseq_metaphlan_genus = makePhyloseqFromTreeSE(tse_metaphlan_genus)

deseq2_metaphlan_genus = phyloseq_to_deseq2(phyloseq_metaphlan_genus, design = ~condition)
```

## 5.2 Running differential analysis on diseased vs healthy 

```{r, message=FALSE}
dds_genus = deseq2_metaphlan_genus

design(dds_genus) <- ~ condition  # Replace with your column name for condition

# Run DESeq2 analysis
dds_genus <- DESeq(dds_genus)
```


## 5.3 Extracting results for disease state 

```{r, message=FALSE}
# Extract results for diseased vs healthy
res_genus <- results(dds_genus, contrast = c("condition", "diseased", "healthy"))

string <- "NA_p__Actinobacteria_c__Actinobacteria_o__Streptomycetales_f__Streptomycetaceae_g__Streptomyces"
string_result <- gsub(".*(g__Streptomyces)", "\\1", string)
print(string_result)

# Clean up genus names for dds
rownames(dds_genus) <- gsub(".*(g__*)", "\\1", rownames(dds_genus))

# Clean up genus names for res
res_genus@rownames <- gsub(".*(g__*)", "\\1", res_genus@rownames)


```



## 5.4 Plotting output as volcano plot

```{r}
deseq_volcano_g = ggplot(as.data.frame(res_genus), 
       aes(x = log2FoldChange, 
           y = -log10(pvalue), 
           color = ifelse(-log10(pvalue) > 1.3, log2FoldChange > 0, "grey"), 
           label = ifelse(-log10(pvalue) > 1.3, as.character(rownames(as.data.frame(res_genus))), ''))) +
  geom_point() + 
  geom_hline(yintercept = 1.3) + 
  scale_color_manual(name = "Log2 fold change", 
                     values = c("TRUE" = "#E47273", "FALSE" = "#6DA6CE", "grey" = "grey")) +
  theme_minimal() +
  labs(title = "Differential Abundance Analysis",
       x = "Log2 Fold Change",
       y = "-Log10 P-Value") +
  geom_label_repel() 

deseq_volcano_g 

ggsave("../imgs/Figure_2A.png", plot =  deseq_volcano_g, width = 28, height = 16, dpi = 400)
```

## 5.5 Inspecting Genera that are significantly different between disease states 

```{r}
# Sort summary list by p-value
res_ordered_genus <- res_genus[order(res_genus$padj),]
head(res_ordered_genus)
head(res_ordered_genus, n =20)

# Filter for significant species 
significant_genus <- as.data.frame(res_genus) %>%
  filter(padj < 0.05)
head(significant_genus)

# Filter for significant species with higher abundance in healthy samples
significant_genus_less_thn_zero <- as.data.frame(res_genus) %>%
  filter(padj < 0.05, log2FoldChange < 0)


# Filter for significant species with higher abundance in diseased samples
significant_genus_grtr_thn_zero <- as.data.frame(res_genus) %>%
  filter(padj < 0.05, log2FoldChange > 0)

# Print the results
head(significant_genus_grtr_thn_zero)
head(significant_genus_less_thn_zero)
```

For noma samples 

```{r}

# Order the results 
sig_res_genus <- significant_genus[order(significant_genus$padj),]
head(sig_res_genus)
head(sig_res_genus, n= 15)

# Order the results by significance greater than zero (Noma)
sig_res_genus_grtr_thn_zero <- significant_genus_grtr_thn_zero[order(significant_genus_grtr_thn_zero$padj),]
sig_res_genus_grtr_thn_zero$genus = rownames(sig_res_genus_grtr_thn_zero)
head(as.data.frame(sig_res_genus_grtr_thn_zero, n = 30))

deseq_genus_sig_diff_noma = head(sig_res_genus_grtr_thn_zero, n = 30)

# Order the results by change greater than zero (Noma)
change_res_genus_grtr_thn_zero <- significant_genus_grtr_thn_zero[order(significant_genus_grtr_thn_zero$log2FoldChange),]
head(change_res_genus_grtr_thn_zero, n  = 15)
```


For healthy samples

```{r}
# Order the results by significance less than zero (healthy)
sig_res_genus_less_thn_zero <- significant_genus_less_thn_zero[order(significant_genus_less_thn_zero$padj),]
sig_res_genus_less_thn_zero$genus = rownames(sig_res_genus_less_thn_zero)
head(as.data.frame(sig_res_genus_less_thn_zero, n =30))


deseq_genus_sig_diff_healthy = head(sig_res_genus_less_thn_zero, n = 30)

# Order the results by change greater than zero (healthy)
change_res_genus_less_thn_zero <- significant_genus_less_thn_zero[order(significant_genus_less_thn_zero$log2FoldChange),]
head(as.data.frame(change_res_genus_less_thn_zero, n =15))
```


## 5.6 Look for highly abundant significant ones

```{r}
taxonomyRanks(tse_metaphlan)

# make an assay for abundance
tse_metaphlan <- transformAssay(tse_metaphlan, assay.type="counts", method="relabundance")

# make an altExp and matrix for Genus
altExp(tse_metaphlan,"Genus") <- agglomerateByRank(tse_metaphlan,"Genus")

# make a dataframe of relative abundance 
relabundance_df_Genus <- as.data.frame(assay(altExp(tse_metaphlan, "Genus"), "relabundance"))

# make a matric of relative abundance 
relabundance_matrix_Genus <- assay(altExp(tse_metaphlan, "Genus"), "relabundance")

# calculate the total relative abundance of each Genus (row sums)
total_relabundance_Genus <- rowSums(relabundance_matrix_Genus)

# Get the top highly abundant genera based on relative abundance 
top_Genus_numbers_basic = sort(total_relabundance_Genus, decreasing = TRUE)

# Make into dataframe
top_Genus_numbers_df = as.data.frame(top_Genus_numbers_basic)

# Make into tibble
top_Genus_numbers = as.tibble(top_Genus_numbers_df)

# Rename genera to remove any higher taxonomic names (a quirk of the metaphaln style)
rownames(top_Genus_numbers_df) <- gsub(".*(g__*)", "\\1", rownames(top_Genus_numbers_df))

# Get percenatge by dividing by totoal number of samples (21) and * by 100
top_Genus_pc = top_Genus_numbers %>% 
  mutate(top_Genus_percentage = (top_Genus_numbers_basic/21) * 100) %>% 
  mutate(top_Genus = rownames(top_Genus_numbers_df))

# Select only the top 20 genera by relative abundance 
top_Genus_pc$top_20_Genus = ifelse(top_Genus_pc$top_Genus %in% top_Genus, top_Genus_pc$top_Genus, "-other")

# Select only the top genera with a relative abundance above 1%
top_Genus_pc$top_Genus_above_1 = ifelse(top_Genus_pc$top_Genus_percentage > 1, top_Genus_pc$top_Genus, "-other")
top_Genus_above_1 = unique(top_Genus_pc$top_Genus_above_1)

# Select 
sig_res_genus_grtr_thn_zero$genera_above_1pc_relab = ifelse(sig_res_genus_grtr_thn_zero$genus %in% top_Genus_above_1, sig_res_genus_grtr_thn_zero$genus, "-other")
sig_res_genus_less_thn_zero$genera_above_1pc_relab = ifelse(sig_res_genus_less_thn_zero$genus %in% top_Genus_above_1, sig_res_genus_less_thn_zero$genus, "-other")

# Check which genera are both signifiantly different and highly abundant 
unique(sig_res_genus_grtr_thn_zero$genera_above_1pc_relab)
unique(sig_res_genus_less_thn_zero$genera_above_1pc_relab)

head(as.data.frame(sig_res_genus_grtr_thn_zero, n=10))



```

## 5.7 Plotting p-values 

Plotting for noma 

```{r}

sig_res_genus_grtr_thn_zero_above_1pc_relab = sig_res_genus_grtr_thn_zero %>% filter(genera_above_1pc_relab != "-other")
sig_res_genus_grtr_thn_zero_above_1pc_relab = sig_res_genus_grtr_thn_zero_above_1pc_relab[!grepl("NA_p__Firmicutes_c__Clostridia_o__Clostridiales_f__Lachnospiraceae_NA", sig_res_genus_grtr_thn_zero_above_1pc_relab$genus), ]


padj_plot_noma <- ggplot(sig_res_genus_grtr_thn_zero_above_1pc_relab, aes(x = reorder(genera_above_1pc_relab, `padj`), y = `padj`)) + 
  geom_bar(stat = "identity", fill = "#D1352B") + 
  geom_text(aes(label = round(`padj`, 4)), 
            hjust = 1.2, # Adjust horizontal position (slightly outside the bars)
            vjust = 0.5, # Center vertically
            size = 6, # Adjust text size
            color = "black") + 
  coord_flip() +  # Flip to make the plot horizontal
  labs(
    title = "Most significantly different genera above 1% abundance noma related",
    x = "Genus",
    y = "Adjusted p-value"
  ) + 
  theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(hjust = 0.5)# Center the title
  )

padj_plot_noma

ggsave("../imgs/Figure_2E.png", plot =  padj_plot_noma, width = 28, height = 16, dpi = 400)

```

Plotting for healthy 

```{r}

# Plot for Healthy
sig_res_genus_less_thn_zero_above_1pc_relab = sig_res_genus_less_thn_zero %>% filter(genera_above_1pc_relab != "-other")
sig_res_genus_less_thn_zero_above_1pc_relab = sig_res_genus_less_thn_zero_above_1pc_relab[!grepl("NA_p__Firmicutes_c__Clostridia_o__Clostridiales_f__Clostridiales_Family_XIII._Incertae_Sedis_NA", sig_res_genus_less_thn_zero_above_1pc_relab$genus), ]
sig_res_genus_less_thn_zero_above_1pc_relab = sig_res_genus_less_thn_zero_above_1pc_relab[!grepl("NA_p__Candidatus_Saccharibacteria_NA_NA_NA_NA", sig_res_genus_less_thn_zero_above_1pc_relab$genus), ]


padj_plot_healthy <- ggplot(sig_res_genus_less_thn_zero_above_1pc_relab, aes(x = reorder(genera_above_1pc_relab, `padj`), y = `padj`)) + 
  geom_bar(stat = "identity", fill = "steelblue") + 
  geom_text(aes(label = round(`padj`, 4)), 
            hjust = 1.2, # Adjust horizontal position (slightly outside the bars)
            vjust = 0.5, # Center vertically
            size = 6, # Adjust text size
            color = "black") + 
  coord_flip() +  # Flip to make the plot horizontal
  labs(
    title = "Most significantly different genera above 1% abundance noma related",
    x = "Genus",
    y = "Adjusted p-value"
  ) + 
  theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(hjust = 0.5)# Center the title
  )

padj_plot_healthy

ggsave("../imgs/Figure_2D.png", plot =  padj_plot_healthy, width = 28, height = 16, dpi = 400)
```

## 5.8 Plotting normalised counts as boxplots 

First we create a function 


```{r}
plotCountsGGanysig <- function(dds, gene, intgroup = "condition", normalized = TRUE,  
                         transform = TRUE, main, xlab = "group", returnData = FALSE,  
                         replaced = FALSE, pc, plot = "point", text = TRUE, showSignificance = TRUE, ...) {  
  # Check input gene validity
  stopifnot(length(gene) == 1 & (is.character(gene) | (is.numeric(gene) &  
                                                         (gene >= 1 & gene <= nrow(dds)))))  
  
  # Check if all intgroup columns exist in colData
  if (!all(intgroup %in% names(colData(dds))))  
    stop("all variables in 'intgroup' must be columns of colData")  
  
  # If not returning data, ensure intgroup variables are factors
  if (!returnData) {  
    if (!all(sapply(intgroup, function(v) is(colData(dds)[[v]], "factor")))) {  
      stop("all variables in 'intgroup' should be factors, or choose returnData=TRUE and plot manually")  
    }  
  }  
  
  # Set pseudo count if not provided
  if (missing(pc)) {  
    pc <- if (transform) 0.5 else 0  
  }  
  
  # Estimate size factors if missing
  if (is.null(sizeFactors(dds)) & is.null(normalizationFactors(dds))) {  
    dds <- estimateSizeFactors(dds)  
  }  
  
  # Get the counts for the gene
  cnts <- counts(dds, normalized = normalized, replaced = replaced)[gene, ]  
  
  # Generate grouping variable
  group <- if (length(intgroup) == 1) {  
    colData(dds)[[intgroup]]  
  } else if (length(intgroup) == 2) {  
    lvls <- as.vector(t(outer(levels(colData(dds)[[intgroup[1]]]),  
                              levels(colData(dds)[[intgroup[2]]]), function(x, y) paste(x, y, sep = ":"))))  
    droplevels(factor(apply(as.data.frame(colData(dds)[, intgroup, drop = FALSE]), 1, paste, collapse = ":"),  
                      levels = lvls))  
  } else {  
    factor(apply(as.data.frame(colData(dds)[, intgroup, drop = FALSE]), 1, paste, collapse = ":"))  
  }  
  
  # Create the data frame with counts, group, and sample names
  data <- data.frame(count = cnts + pc, group = group, sample = colnames(dds), condition = group)  
  
  # Set log scale if necessary
  logxy <- if (transform) "y" else ""  
  
  # Set the plot title
  if (missing(main)) {  
    main <- if (is.numeric(gene)) {  
      rownames(dds)[gene]  
    } else {  
      gene  
    }  
  }  
  
  # Set the y-axis label based on normalization
  ylab <- ifelse(normalized, "normalized count", "count")  
  
  # Return the data if requested
  if (returnData)  
    return(data.frame(count = data$count, colData(dds)[intgroup]))  
  
  # Create the base ggplot object with data and aesthetic mappings
  p <- ggplot(data, aes(x = group, y = count, label = sample, color = condition)) +
    labs(x = xlab, y = ylab, title = main) +  # Labels and title
    theme_minimal() +  # Clean theme
    scale_y_continuous(trans = ifelse(transform, "log10", "identity")) +  # Apply log transformation if needed
    scale_color_brewer(palette = "Set1")  # Optional: use color brewer for nice color scheme
  
  # Select the type of plot based on the 'plot' argument
  if (plot == "point") {
    p <- p + geom_point(size = 3)
    if (text) p <- p + geom_text(hjust = -0.2, vjust = 0)  # Add text if text = TRUE
  } else if (plot == "jitter") {
    p <- p + geom_jitter(size = 3, width = 0.2)
    if (text) p <- p + geom_text(hjust = -0.2, vjust = 0)  # Add text if text = TRUE
  } else if (plot == "bar") {
    p <- p + geom_bar(stat = "summary", fun = "mean", position = "dodge", width = 0.7) +  # Bar plot with whiskers
      geom_errorbar(stat = "summary", fun.data = "mean_se", width = 0.2)
  } else if (plot == "violin") {
    p <- p + geom_violin(trim = FALSE) + geom_jitter(size = 2, width = 0.2)
    if (text) p <- p + geom_text(hjust = -0.2, vjust = 0)  # Add text if text = TRUE
  } else if (plot == "box") {
    p <- p + geom_boxplot()
    if (text) p <- p + geom_text(hjust = -0.2, vjust = 0)  # Add text if text = TRUE
  } else {
    stop("Invalid plot type. Choose from 'point', 'jitter', 'bar', 'violin', or 'box'.")
  }
  
  # Add significance annotation if requested
  if (showSignificance) {
    # Get DESeq2 results for gene using Wald test and BH adjustment
    res <- results(dds, contrast = c(intgroup, levels(group)[1], levels(group)[2]), alpha = 0.05)
    res_gene <- res[gene, ]
    
    # Check significance and add stars/annotations
    if (!is.na(res_gene$padj) && res_gene$padj < 0.05) {
      p <- p + annotate("text", x = 1.5, y = max(data$count), label = "*", size = 8)
    }
  }
  
  print(p)
}
```

Next we use the function to plot any highly abundant significantly associated with Noma 

```{r, warning=FALSE}
# Significant highly abundant for Noma above 1%
plot_1 = plotCountsGGanysig(dds_genus, gene="g__Treponema", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_2 = plotCountsGGanysig(dds_genus, gene="g__Porphyromonas", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_3 = plotCountsGGanysig(dds_genus, gene="g__Bacteroides", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_4 = plotCountsGGanysig(dds_genus, gene="g__Selenomonas", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
grid.arrange(plot_1, plot_2, plot_3, plot_4, ncol=2)

ggsave("../imgs/Figure_2C.png", 
       arrangeGrob(plot_1, plot_2, plot_3, plot_4, ncol=2),
       width = 10,
       height = 20)
```

Then we use the function to plot any highly abundant signifcantly asscoiated with healthy global dataset

```{r, warning=FALSE}
# Significant highly abundant for healthy above 1%
plot_1 = plotCountsGGanysig(dds_genus, gene="g__Streptococcus", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_2 = plotCountsGGanysig(dds_genus, gene="g__Veillonella", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_3 = plotCountsGGanysig(dds_genus, gene="g__Gemella", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_4 = plotCountsGGanysig(dds_genus, gene="g__Schaalia", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_5 = plotCountsGGanysig(dds_genus, gene="g__Rothia", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_6 = plotCountsGGanysig(dds_genus, gene="g__Actinomyces", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
plot_7 = plotCountsGGanysig(dds_genus, gene="g__Haemophilus", intgroup = "condition", plot = "box", text = FALSE, showSignificance = TRUE)
grid.arrange(plot_1, plot_2, plot_3, plot_4,
             plot_5, plot_6, plot_7, ncol=2)

ggsave("../imgs/Figure_2B.png", 
       arrangeGrob(plot_1, plot_2, plot_3, plot_4,
             plot_5, plot_6, plot_7, ncol=2),
       width = 10,
       height = 20)
```



## 5.9 Comparing noma samples against the three separate healthy cohorts


###  5.9.1 Add additional metadata relating to specific healthy controls

```{r}

# Define the function to update metadata
update_sample_metadata <- function(tse_object) {
  # Extract sample names (column names)
  sample_names <- colnames(tse_object)
  
  # Create the "accession" column based on sample name prefix
  accession <- ifelse(grepl("^SRS", sample_names), "SRS",
                      ifelse(grepl("^SRR", sample_names), "SRR",
                             ifelse(grepl("^A", sample_names), "noma",
                                    ifelse(grepl("^DRR", sample_names), "DRR", NA))))
  
  # Create the "location" column based on sample name prefix
  location <- ifelse(grepl("^SRS", sample_names), "USA",
                     ifelse(grepl("^SRR", sample_names), "Denmark",
                            ifelse(grepl("^A", sample_names), "Nigeria",
                                   ifelse(grepl("^DRR", sample_names), "Japan", NA))))
  
  # Create a DataFrame with the new metadata columns
  sample_metadata <- DataFrame(accession = accession, location = location)
  rownames(sample_metadata) <- sample_names
  
  # Add the metadata as colData to the TreeSummarizedExperiment object
  colData(tse_object) <- sample_metadata
  
  # Return the updated object
  return(tse_object)
}

# Example usage:
tse_metaphlan_genus_hc = altExp(tse_metaphlan, "Genus") 
tse_metaphlan_genus_hc <- update_sample_metadata(tse_metaphlan_genus_hc)

head(as.data.frame(colData(tse_metaphlan_genus_hc)))
```


###  5.9.2 Convert data

```{r}

# Add this DataFrame as colData to your TreeSummarizedExperiment object
colData(tse_metaphlan_genus_hc) 
unique(colData(tse_metaphlan_genus_hc))

# Use makePhyloseqFromTreeSE from Miaverse

phyloseq_metaphlan_hc = makePhyloseqFromTreeSE(tse_metaphlan_genus_hc)

deseq2_metaphlan_hc = phyloseq::phyloseq_to_deseq2(phyloseq_metaphlan_hc, design = ~ accession)


```

###  5.9.3 Run differential analysis between seperate datasets

```{r, message=FALSE, warning=FALSE}

dds_hc = deseq2_metaphlan_hc

design(dds_hc) <- ~ accession  # Replace with your column name for condition

# Run DESeq2 analysis
dds_hc <- DESeq(dds_hc)

# Clean up genus names for dds
rownames(dds_hc) <- gsub(".*(g__*)", "\\1", rownames(dds_hc))

```


###  5.9.4 Extract results for disease state 

```{r}

unique(as.data.frame(colData(tse_metaphlan_genus_hc)))

# Extract results for diseased vs healthy
res_SRR_noma <- results(dds_hc, contrast = c("accession", "noma", "SRR"))
res_DRR_noma <- results(dds_hc, contrast = c("accession", "noma", "DRR"))
res_SRS_noma <- results(dds_hc, contrast = c("accession", "noma", "SRS"))


```


###  5.9.5 Plot counts of genera between diseased and healthy


Here we introduce another function which plots lines for significance 

```{r, warning=FALSE}

plotCountsGGsigline = function(dds, gene, intgroup = "condition", normalized = TRUE,
                               transform = TRUE, main, xlab = "group", returnData = FALSE,
                               replaced = FALSE, pc, plot = "point", text = TRUE,
                               showSignificance = TRUE, lineSpacing = 0.1,
                               groupOrder = NULL, ...) {
  
  # input checks
  stopifnot(length(gene)==1 && (is.character(gene) ||
                                  (is.numeric(gene) && gene>=1 && gene<=nrow(dds))))
  if (!all(intgroup %in% names(colData(dds))))
    stop("all variables in 'intgroup' must be columns of colData")
  if (!returnData) {
    if (!all(sapply(intgroup, function(v) is(colData(dds)[[v]], "factor"))))
      stop("all variables in 'intgroup' should be factors, or choose returnData=TRUE")
  }
  
  # pseudo-count
  if (missing(pc)) pc <- if (transform) 0.5 else 0
  
  # ensure size factors
  if (is.null(sizeFactors(dds)) && is.null(normalizationFactors(dds)))
    dds <- estimateSizeFactors(dds)

  
  # extract counts + grouping
  cnts  <- counts(dds, normalized=normalized, replaced=replaced)[gene,]
  if (length(intgroup)==1) {
    group <- colData(dds)[[intgroup]]
  } else {
    lvls  <- as.vector(t(outer(levels(colData(dds)[[intgroup[1]]]),
                               levels(colData(dds)[[intgroup[2]]]),
                               paste, sep=":")))
    group <- droplevels(factor(
      apply(as.data.frame(colData(dds)[,intgroup]),1,paste,collapse=":"),
      levels=lvls))
  }
  
  # Set order of groups on the x-axis if specified
  if (!is.null(groupOrder)) {
    group <- factor(group, levels = groupOrder)
  }
  
  data <- data.frame(count=cnts+pc,
                     group=group,
                     sample=colnames(dds),
                     condition=group)
  
  # axis labels
  ylab <- ifelse(normalized, "normalized count", "count")
  logxy <- ifelse(transform, "y", "")
  
  if (missing(main)) {
    main <- if (is.numeric(gene)) rownames(dds)[gene] else gene
  }
  if (returnData) {
    return(data.frame(count=data$count, colData(dds)[intgroup]))
  }
  
  # base ggplot
  p <- ggplot(data, aes(x=group,y=count,label=sample,
                        color=condition,group=group)) +
    labs(x=xlab, y=ylab, title=main) +
    theme_minimal() +
    scale_y_continuous(trans=ifelse(transform,"log10","identity")) +
    scale_color_brewer(palette="Set1")
  
  # choose geom
  if (plot=="point") {
    p <- p + geom_point(size=3)
    if (text) p <- p + geom_text(hjust=-0.2, vjust=0)
  } else if (plot=="jitter") {
    p <- p + geom_jitter(size=3,width=0.2)
    if (text) p <- p + geom_text(hjust=-0.2, vjust=0)
  } else if (plot=="bar") {
    p <- p + geom_bar(stat="summary", fun="mean",
                      position="dodge", width=0.7) +
      geom_errorbar(stat="summary", fun.data="mean_se", width=0.2)
  } else if (plot=="violin") {
    p <- p + geom_violin(trim=FALSE) +
      geom_jitter(size=2,width=0.2)
    if (text) p <- p + geom_text(hjust=-0.2, vjust=0)
  } else if (plot=="box") {
    p <- p + geom_boxplot() +
      geom_jitter(size=2,width=0.2)
    if (text) p <- p + geom_text(hjust=-0.2, vjust=0)
  } else {
    stop("Invalid plot type. Choose from 'point','jitter','bar','violin','box'.")
  }
  
  # add significance lines & stars
  if (showSignificance) {
    max_y    <- max(data$count)
    step     <- max_y * lineSpacing
    counter  <- 0
    
    for (i in 1:(nlevels(group) - 1)) {
      for (j in (i + 1):nlevels(group)) {
        contrast <- c(intgroup, levels(group)[i], levels(group)[j])
        res      <- results(dds, contrast = contrast, alpha = 0.05)
        pv       <- as.numeric(res[gene, "padj"])
        
        # Determine label and color
        if (is.na(pv) || pv > 0.05) {
          lab <- "ns"
          col <- "grey70"
          size <- 3
        } else if (pv <= 0.001) {
          lab <- "***"
          col <- "black"
          size <- 6
        } else if (pv <= 0.01) {
          lab <- "**"
          col <- "black"
          size <- 6
        } else {
          lab <- "*"
          col <- "black"
          size <- 6
        }
        
        # Positioning
        counter <- counter + 1
        y_line  <- max_y + step * counter
        
        # Add line and label
        p <- p +
          annotate("segment",
                   x = i, xend = j,
                   y = y_line, yend = y_line,
                   colour = col) +
          annotate("text",
                   x = mean(c(i, j)),
                   y = y_line + (step * 0.05),
                   label = lab,
                   size = size,
                   colour = col)
      }
    }
  }
  
  print(p)
}

```

Now plot the different genera 

```{r, warning=FALSE}

plot_1 = plotCountsGGsigline(dds_hc, gene= "g__Treponema", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_2 = plotCountsGGsigline(dds_hc, gene= "g__Bacteroides", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_3 = plotCountsGGsigline(dds_hc, gene= "g__Porphyromonas", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_4 = plotCountsGGsigline(dds_hc, gene= "g__Selenomonas", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_5 = plotCountsGGsigline(dds_hc, gene= "g__Prevotella", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_6 = plotCountsGGsigline(dds_hc, gene= "g__Streptococcus", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_7 = plotCountsGGsigline(dds_hc, gene= "g__Rothia", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_8 = plotCountsGGsigline(dds_hc, gene= "g__Veillonella", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_9 = plotCountsGGsigline(dds_hc, gene= "g__Gemella", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_10 = plotCountsGGsigline(dds_hc, gene= "g__Schaalia", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_11 = plotCountsGGsigline(dds_hc, gene= "g__Actinomyces", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))
plot_12 = plotCountsGGsigline(dds_hc, gene= "g__Haemophilus", intgroup = "accession", plot = "box", text = FALSE, showSignificance = TRUE, lineSpacing = 5, groupOrder = c("noma", "DRR", "SRR", "SRS"))

grid.arrange(plot_1, plot_2, plot_3, plot_4, plot_5,
             plot_6, plot_7, plot_8, plot_9, plot_10,
             plot_11, plot_12, ncol=3)

ggsave("../imgs/Supplementary_Figure_2.png", 
arrangeGrob(plot_1, plot_2, plot_3, plot_4, plot_5,
             plot_6, plot_7, plot_8, plot_9, plot_10,
             plot_11, plot_12, ncol=3),
width = 20,
height = 10)

```


# 6. Random Forests 

Random forest (RF) classifiers were applied based on 500 estimator trees to identify key predictors of microbial community composition and their association with noma or healthy states. 

We also ran a cross validation of the dataset taking 20% of samples as test data and 80% as training data. This was used to assess the predictive power of the RF classifier, assessed as an area under the receiver operating characteristic (ROC) curve (AUC) between 0 and 1.

A permutation test (n = 1000) was conducted to evaluate the statistical significance of the observed classification accuracy, this allowed for a null distribution of accuracy to be plotted. The observed accuracy of the random forest model was overlayed on the null distribution. 

## 6.1 Preparing the data

```{r, warning=FALSE, message=FALSE}


  
  # Extract metadata and OTU table
  phyloseq_obj <- phyloseq_noma_esd
  metadata <- data.frame(sample_data(phyloseq_obj))
  otu_data <- as.data.frame(otu_table(phyloseq_obj))
  otu_data <- t(otu_data)  # Transpose so samples are rows and species are columns
  
  # Combine OTU data with metadata
  ml_data <- cbind(metadata, otu_data)
  
  # Ensure the metadata column you're predicting (e.g., condition) is a factor
  ml_data$condition <- as.factor(ml_data$condition)  # Replace "condition" with your actual column
  
  # Remove columns containing NA
  ml_data_clean <- ml_data[, !is.na(colnames(ml_data))]
  ml_data_clean <- ml_data[, !grepl("NA", colnames(ml_data))]
  
  set.seed(123456)
  rf_model_cv <- randomForest(condition ~ ., data = ml_data_clean, ntree = 500, importance = TRUE)
  print(rf_model_cv)
  importance_rf_model_cv <- importance(rf_model_cv)
  
  
  # Delete everything from start to Genus
  ml_data_col_names = sub(".*_g__","",colnames(ml_data))
  # Add Genus back in 
  ml_data_clean = paste0(paste(rep("g__", length(ml_data_col_names)), ml_data_col_names))
  # Delete the space introduced by this 
  ml_data_col_names = sub(" ","",ml_data_col_names)
  ml_data_col_names = sub("g__condition","condition",ml_data_col_names)
  head(ml_data_col_names)
  
  ml_data_clean = ml_data
  colnames(ml_data_clean) = ml_data_col_names
  
```
 
## 6.2 running random forests
 
```{r}
  set.seed(12345)
  # Run Random Forest to classify samples based on 'condition'
  rf_model <- randomForest(condition ~ ., data = ml_data_clean, ntree = 500, importance = TRUE)
  print(rf_model)
  importance_rf_model <- importance(rf_model)
  
  set.seed(12345)
  # Run Random Forest to classify samples based on 'condition'
  rf_model_condition <- randomForest(condition ~ ., data = ml_data_clean, ntree = 500, importance = TRUE)
  print(rf_model_condition)
  importance_rf_model <- importance(rf_model_condition)
  head(importance_rf_model)
```

 
## 6.3 Plot variable importance
 
```{r}
  # Plot Variable Importance
  # To plot the variable importance, use the %IncMSE (or MeanDecreaseAccuracy) 
  # from the importance output. Below is an example of how to create a bar plot 
  # of the top 10 most important predictors:
  

  
  # Extract variable importance and convert to a data frame
  importance_df <- as.data.frame(importance_rf_model)
  importance_df <- tibble::rownames_to_column(importance_df, "genus")
  
  importance_df <- importance_df %>%
    dplyr::arrange(desc(`MeanDecreaseAccuracy`)) %>%
    dplyr::slice_head(n = 50)  # Select top 10 most important predictors
  
  # select by any above 1.7
  importance_df <- importance_df %>%
    filter(`MeanDecreaseAccuracy`>1.7) %>% 
    arrange(desc(`MeanDecreaseAccuracy`))
  
  importance_df_ggplot = importance_df %>% filter(!grepl("NA", genus))
  
  # Plot the top 10 important predictors
  gp = ggplot(importance_df_ggplot, aes(x = reorder(genus, `MeanDecreaseAccuracy`), y = `MeanDecreaseAccuracy`)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +  # Flip to make the plot horizontal
    labs(
      title = "Top Most Important Genus Predictors in Random Forest",
      x = "Genus",
      y = "Increase in Mean Squared Error (%IncMSE)"
    ) +
    theme_minimal(base_size = 10)
  
  gp
  
  # Select only the top genera with a relative abundance above 1%
  top_Genus_pc$top_Genus_above_1 = ifelse(top_Genus_pc$top_Genus_percentage > 1, top_Genus_pc$top_Genus, "-other")
  top_Genus_above_1 = unique(top_Genus_pc$top_Genus_above_1)
  top_Genus_above_1_nog =  gsub("g__", "", top_Genus_above_1)
  top_Genus_above_1_nog

  
# Select genera above 1% 
  
importance_df$genera_above_1pc = ifelse(importance_df$genus %in% top_Genus_above_1, importance_df$genus, "-other")
unique(importance_df$genera_above_1pc)

importance_df

importance_df_to_plot = importance_df %>% filter(genera_above_1pc != "-other") %>% filter(!grepl("NA", genus))

# Plot the top 10 important predictors above 1%
gp2 = ggplot(importance_df_to_plot, aes(x = reorder(genera_above_1pc, `MeanDecreaseAccuracy`), y = `MeanDecreaseAccuracy`)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip to make the plot horizontal
  labs(
    title = "Top Most Important Genera Predictors",
    x = "Genera above 1% overall abundance",
    y = "Increase in Mean Squared Error (%IncMSE)"
  ) +
  theme_minimal(base_size = 10)

gp2

ggsave("../imgs/Figure_3A.png", plot = gp2, width = 28, height = 16, dpi = 400)
```

## 6.4 Cross validation 

### 6.4.1 Cross validation 
 
```{r}
  
  otu_table_g = as.data.frame(otu_table(phyloseq_obj))
  
  colnames(otu_table_g) <- gsub(".*(g__*)", "\\1", colnames(otu_table_g))
  colnames(otu_table_g)
  
  # Remove columns containing NA
  otu_table_g <- otu_table_g[, !is.na(colnames(otu_table_g))]
  otu_table_g <- otu_table_g[, !grepl("NA", colnames(otu_table_g))]
  
  colSums(is.na(otu_table_g)) 
  
  #otu_table_g = t(otu_table_g)
  
  condition = as.data.frame(metadata$condition)
  rownames(condition) = rownames(metadata)
  
  otu_table_g = t(otu_table_g)
  
  otu_table_g <- cbind(condition, otu_table_g)
  
  # Split data into training and test sets (80/20 split)
  set.seed(123456)
  train_index <- sample(1:nrow(otu_table_g), 0.8 * nrow(otu_table_g))
  train_data <- otu_table_g[train_index, ]
  test_data <- otu_table_g[-train_index, ]
  
  dim(train_data)  # Check dimensions of your dataset
  dim(test_data) 
  
  train_data$`metadata$condition` <- as.factor(train_data$`metadata$condition`)

  # Train Random Forest
  rf_model_2 <- randomForest(`metadata$condition` ~ ., data = train_data, importance = TRUE)
  
  # Predict on test set
  pred <- predict(rf_model_2, test_data, type = "prob")[, 2]
  
  # Evaluate model performance
  roc_obj <- roc(test_data$`metadata$condition`, pred)
  roc_plot = plot(roc_obj, main = "ROC Curve for Random Forest")
  roc_plot
  auc(roc_obj)
```

### 6.4.1 Train random forests model with 80% of dataset

```{r, warning=FALSE, message=FALSE}
# Load required libraries


# Split data into training and testing sets
# This is a crucial step you were missing
set.seed(123456) # For reproducibility
train_index <- createDataPartition(ml_data_clean$condition, p = 0.8, list = FALSE)
train_data <- ml_data_clean[train_index, ]
test_data <- ml_data_clean[-train_index, ]

# Train Random Forest model on training data
rf_model_cv <- randomForest(condition ~ ., 
                         data = train_data, 
                         ntree = 500, 
                         importance = TRUE)

# Print model summary
print(rf_model_cv)
```

### 6.4.1 Variable importance
```{r}
# Variable importance
importance_rf_model_cv <- importance(rf_model_cv)
varImpPlot(rf_model_cv, main = "Variable Importance")
```


### 6.4.1 Predicting probabilities of test data based on trained model
```{r}
# Evaluate on testing data - never evaluate on the same data you trained on
predictions_prob <- predict(rf_model_cv, test_data, type = "prob")

# Check structure of predictions
str(predictions_prob)

# Extract probabilities for the positive class (assuming binary classification)
# If condition has levels "No" and "Yes" or "0" and "1"
# Get the column name of the positive class (typically the second column)
positive_class <- colnames(predictions_prob)[2]
prob_positive <- predictions_prob[, positive_class]

# Create class predictions based on probability threshold
threshold <- 0.5
predictions_class <- factor(ifelse(prob_positive > threshold, 
                                  levels(test_data$condition)[2], 
                                  levels(test_data$condition)[1]),
                           levels = levels(test_data$condition))

# Create confusion matrix
conf_matrix <- confusionMatrix(predictions_class, test_data$condition)
print(conf_matrix)
```

### 6.4.1 ROC curve and AUC with ROCR
```{r}
# ROC curve using ROCR
# For ROCR, we need numeric labels (convert factor to numeric)
numeric_labels <- as.numeric(test_data$condition) - 1  # Convert to 0/1
roc_pred <- prediction(predictions = prob_positive, labels = numeric_labels)
roc_perf <- performance(roc_pred, "tpr", "fpr")

# Plot ROC curve
plot(roc_perf,
     colorize = TRUE,
     print.cutoffs.at = seq(0, 1, 0.1),
     text.adj = c(-0.2, 1.7),
     main = "ROC Curve")
abline(a = 0, b = 1, lty = 2, col = "gray")

# Calculate AUC
auc_ROCR <- performance(roc_pred, measure = "auc")
auc_value <- auc_ROCR@y.values[[1]]
print(paste("AUC:", round(auc_value, 4)))

```

### 6.4.1 ROC curve and AUC with pROC
```{r}

# Alternative ROC curve using pROC package
roc_curve <- roc(response = test_data$condition, 
                predictor = prob_positive)
plot(roc_curve, main = "ROC Curve using pROC")
print(paste("AUC (pROC):", round(auc(roc_curve), 4)))

# Save as pnf file
# 1. Open png file
png("../imgs/Figure_3B.png", width = 256, height = 256, units = "px")
# 2. Create the plot
plot(roc_curve, main = "ROC Curve using pROC")
print(paste("AUC (pROC):", round(auc(roc_curve), 4)))
# 3. Close the file
dev.off()

# Print performance metrics
accuracy <- conf_matrix$overall["Accuracy"]
sensitivity <- conf_matrix$byClass["Sensitivity"]
specificity <- conf_matrix$byClass["Specificity"]

print(paste("Accuracy:", round(accuracy, 4)))
print(paste("Sensitivity:", round(sensitivity, 4)))
print(paste("Specificity:", round(specificity, 4)))
```

  
## 6.5 Permutation testing for RF accuracy 
  
```{r}
  # Ensure column names are correctly referenced
  
  train_data$`metadata$condition`

  colnames(train_data)[colnames(train_data) == "metadata$condition"] <- "condition"
  colnames(test_data)[colnames(test_data) == "metadata$condition"] <- "condition"
  train_data$condition
  test_data$condition

  # Permutation testing
  set.seed(1234)
  null_accuracies <- replicate(1000, {
    # Shuffle the labels
    perm_labels <- sample(train_data$condition)  # Use the actual column name for condition
    train_data_perm <- train_data
    train_data_perm$condition <- perm_labels  # Replace condition labels with permuted ones
    
    # Train random forest on permuted data
    rf_perm <- randomForest(condition ~ ., data = train_data_perm, importance = TRUE)
    
    # Test on test_data
    mean(predict(rf_perm, test_data) == test_data$condition)  # Ensure test_data$condition matches
  })
  
  # Compare observed accuracy to null distribution
  observed_accuracy <- mean(predict(rf_model_cv, test_data) == test_data$condition)

# Calculate the p-value
p_value <- sum(null_accuracies >= observed_accuracy) / length(null_accuracies)

# Print the p-value
print(p_value)
  
  # Visualize and interpret
  
  # 2. Create the plot
  hist(null_accuracies, main =paste("Null Distribution of Accuracy\np-value =", round(p_value, 4)), xlab = "Accuracy")
  abline(v = observed_accuracy, col = "red", lwd = 2)  

  # Save as pnf file
# 1. Open png file
png("../imgs/Figure_3C.png", width = 256, height = 256, units = "px")
# 2. Create the plot
hist(null_accuracies, main =paste("Null Distribution of Accuracy\np-value =", round(p_value, 4)), xlab = "Accuracy")
abline(v = observed_accuracy, col = "red", lwd = 2) 
# 3. Close the file
dev.off()

  
```

# 7. Ordination of multivariate data 

Here we run ordination of multivariate data into two dimensions using the unsupervised learning techniques; Principal Coordinate Analysis (PCoA), Non-metric Multidimensional Scaling (NMDS), and Redundancy Analysis (RDA) all with Bray-Curtis dissimilarity. 

## 7.1 Calculating Bray-Curtis dissimilarity 

```{r}
  phyloseq_obj
  
  phyloseq_obj@sam_data[["condition"]] = as.factor(phyloseq_obj@sam_data[["condition"]])
  
  # Calculate Bray-Curtis dissimilarity
  dist_bc <- phyloseq::distance(phyloseq_obj, method = "bray")

```


## 7.1 PERMANOVA 

```{r}
  dist_bc <- phyloseq::distance(phyloseq_obj, method = "bray")
  adonis2(dist_bc ~ condition, data = as(sample_data(phyloseq_obj), "data.frame"))

```


## 7.3 PCoA

```{r}

  
  # Visualize PCoA
  ordination_results <- ordinate(phyloseq_obj, method = "PCoA", distance = "bray")
  
  # Convert ordination to a data frame
  ordination_df <- as.data.frame(ordination_results$vectors)
  rownames(ordination_df) = rownames(ordination_results$vectors)
  ordination_df$condition <- sample_data(phyloseq_obj)$condition
  head(ordination_df)
  
  # Plot using ggplot2
  PCoA_plot = ggplot(ordination_df, aes(x = Axis.1, y = Axis.2, color = condition)) +
    geom_point(size = 4) +
    theme_minimal() +
    labs(x = "PCoA1", y = "PCoA2")  +
    ggtitle("PCoA") +
    theme_minimal(base_size = 10)
  
  PCoA_plot
  

```

## 7.4 NMDS 

```{r}
  ordination_results <- ordinate(phyloseq_obj, method = "NMDS", distance = "bray")

  # Convert ordination to a data frame
  ordination_df <- as.data.frame(ordination_results$points)
  rownames(ordination_df) = rownames(ordination_results$points)
  ordination_df$condition <- sample_data(phyloseq_obj)$condition
  head(ordination_df)
  
  # Plot using ggplot2
  NMDS_plot = ggplot(ordination_df, aes(x = MDS1, y = MDS2, color = condition)) +
    geom_point(size = 4) +
    labs(x = "MDS1", y = "MDS2")  +
    ggtitle("NMDS") +
    theme_minimal(base_size = 10)
  
  NMDS_plot

```

## 7.5 RDA

```{r}

  # Visualize PCoA
  ordination_results <- ordinate(phyloseq_obj, method = "RDA", distance = "bray")
  
  # Convert ordination to a data frame
  ordination_df <- as.data.frame(ordination_results[["CA"]][["u"]])
  rownames(ordination_df) = rownames(ordination_results[["CA"]][["u"]])
  ordination_df$condition <- sample_data(phyloseq_obj)$condition
  ordination_df$sample_names = rownames(ordination_df)
  head(ordination_df)
  
  # Plot using ggplot2
  RDA_plot = ggplot(ordination_df, aes(x = PC1, y = PC2, color = condition)) +
    geom_point(size = 4) +
    labs(x = "PC1", y = "PC2")  +
    ggtitle("RDA") +
    theme_minimal(base_size = 10)


   RDA_plot 
```

Now we will save all the plots together 

```{r}
grid.arrange(PCoA_plot, NMDS_plot, RDA_plot, ncol=3)

ggsave("../imgs/Figure_3D.png", 
       arrangeGrob(PCoA_plot, NMDS_plot, RDA_plot, ncol=3),
       width = 20,
       height = 10)

```

# 7. Hierachical Clustering of Centered log ratios

Here we plotted a heatmap displaying the z-score standardized centered log-ratio (CLR) of the top 20 most abundant genera.

## 7.1 Preparing the data

```{r}

  # Ensure Genus 
  tse_genus <- altExp(tse_metaphlan, "Genus")
  
  # Add clr-transformation (centred-lofg ratio)
  tse_genus <- transformAssay(tse_genus, assay.type = "counts", method = "relabundance")
  tse_genus <- transformAssay(tse_genus, assay.type = "relabundance",
                              method = "clr", pseudocount = TRUE)
  
  # Apply a z-transformation across rows (taxa)
  tse_genus <- transformAssay(tse_genus, assay.type = "clr", 
                              MARGIN = "features",
                              method = "standardize", name = "clr_z")
  
  # Get 20 most abundant genera, and subsets the data by them
  top_20_genus <- names(sort(total_relabundance_Genus, decreasing = TRUE)[1:20])
  tse_genus_subset <- tse_genus[top_20_genus, ]
  
  # Calculate the proportion of bacteria accounted for in the top 20 Genera
  (sum(assay(tse_genus_subset, "relabundance"))) / 15
  
  # delete to _g__
  rownames(tse_genus_subset) <- gsub(".*(g__*)", "\\1", rownames(tse_genus_subset))
  
  # Gets the assay table
  mat <- assay(tse_genus_subset, "clr_z")
  
  # make a dataframe for sample information
  sample_data <- as.data.frame(colData(tse_genus_subset))
  sample_data <- sample_data[, c("condition"), drop = FALSE]

  # make a dataframe for taxonomic information
  taxonomic_data <- as.data.frame(rowData(tse_genus_subset))
  taxonomic_data <- taxonomic_data[, "Phylum", drop = FALSE]

```

## 7.2 Plotting heatmap of centred log ratios 

```{r}

  # set heatmap scaling and colors
  breaks <- seq(-ceiling(max(abs(mat))), ceiling(max(abs(mat))), 
                length.out = ifelse( max(abs(mat))>5, 2*ceiling(max(abs(mat))), 10 ) )
  colors <- colorRampPalette(c("darkblue", "blue", "white", "red", "darkred"))(length(breaks)-1)
  
  colors <- colorRampPalette(c("#1E3A5F", "#4682B4", "#FFFFFF", "#E41A1C", "#A11618"))(length(breaks) - 1)
  
  # set column annotation colors
  ann_colors <- list(
    condition = c("healthy" = "#4682B4", "diseased" = "#E41A1C"),
    taxonomic_data = c(brewer.pal(6, "Dark2"))
  )
 
  # create the heatmap
  genus_clusters = pheatmap(mat, 
                             annotation_col = sample_data, 
                             annotation_row = taxonomic_data, 
                             annotation_colors = ann_colors, 
                             color = colors, 
                             breaks = breaks,
                             clustering_distance_cols = "euclidean", 
                             clustering_method = "complete")
  
  # print plot
  genus_clusters


  ggsave("../imgs/Figure_3E.png", 
       genus_clusters,
       width = 20,
       height = 12)
  
```
  
## 7.3 Determining mean Centred log ratos 
  
```{r}
  # Combine CLR z-scores with Sample Conditions
  # Combine mat and sample_data
  clr_z_with_condition <- as.data.frame(t(mat))
  clr_z_with_condition$condition <- sample_data$condition
  
  # Specify genera of interest
  genera_of_interest <- top_Genus_above_1
  
  
  # Identify genera present in the CLR z-score data
  valid_genera <- intersect(genera_of_interest, colnames(clr_z_with_condition))
  
  valid_genera = c(valid_genera, "g__Filifactor")
  
  # Subset for valid genera and condition
  clr_z_subset <- clr_z_with_condition[, c(valid_genera, "condition")]
  
  # Calculate mean z-scores
  mean_clr_z_scores <- clr_z_subset %>%
    dplyr::group_by(condition) %>%
    dplyr::summarise(across(everything(), ~ mean(.x, na.rm = TRUE), .names = "mean_{.col}"))
  
  # Calculate means
  mean_clr_z_scores <- clr_z_subset %>%
    dplyr::group_by(condition) %>%
    dplyr::summarise(across(all_of(valid_genera), ~ mean(.x, na.rm = TRUE)))
  
  # View the result
  print(mean_clr_z_scores)
  
  # Convert to long format for ggplot
  clr_z_long <- mean_clr_z_scores %>% 
    pivot_longer(cols = -condition, names_to = "Genus", values_to = "Mean_Z_Score")
  
  
  Mean_CLR_Z_Score = ggplot(clr_z_long, aes(x = Mean_Z_Score, y = condition, fill = condition)) +
    geom_bar(stat = "identity", position = position_dodge(), color = "black") +  # Black border around bars
    facet_wrap(~ Genus, scales = "free_y", ncol = 1) +  # Separate panels for each genus
    labs(x = "Condition", y = "Mean CLR Z-Score", fill = "Condition", title = "Mean CLR Z-Scores by Genus and Condition") +
    theme_minimal(base_size = 5) +
    theme(panel.border = element_rect(color = "black", fill = NA, size = 1))  # Add a border around each panel 
  
  Mean_CLR_Z_Score


  ggsave("../imgs/Figure_3F.png", 
       Mean_CLR_Z_Score,
       width = 10,
       height = 20)

  
```

